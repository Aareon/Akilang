# Microsoft Win32/NT library interfaces

extern SetConsoleOutputCP(codepage :u32) :bool
extern GetConsoleOutputCP() :u32

# We don't yet have the ability to encode variable arguments
# so printf is just one for now
extern printf(str_fmt :ptr i8, int_data :u64) :i32

extern rand():i32

extern GetProcessHeap():ptr_size
extern HeapAlloc(handle:ptr_size, flags:u32, bytes:ptr_size):ptr ptr_size
extern HeapFree(handle:ptr_size, flags:u32, mem:ptr_size): bool

extern _getwch():i32

# extern gets() :i32

extern gets_s(input:ptr i8, bytes:ptr_size)

extern _get_errno(errno:ptr i32) :i32

# implementations of above

def c_alloc(bytes:ptr_size):ptr ptr_size
    HeapAlloc(GetProcessHeap(), 8u, bytes)

def c_alloc(bytes:i32):ptr ptr_size
    #c_alloc(cast(bytes, ptr_size))
    # eventually we can use that when we support inlining
    HeapAlloc(GetProcessHeap(), 8u, cast(bytes, ptr_size))

def c_free(mem:ptr_size):bool
    HeapFree(GetProcessHeap(), 0u, mem)

def inkey():i32 {
    var key:i32
    key=_getwch()
    if (key==0 or key==224) then key=_getwch()
    return key
}

def set_codepage(codepage :u32) :bool
    SetConsoleOutputCP(codepage)

def get_codepage() :u32
    GetConsoleOutputCP()

def rnd(max:i32):i32
    rand()/(32767/max)

 def input():ptr u8{
    var buf=c_obj_alloc({var x:byte[1024] x})
    var err:i32=0
    
    gets_s(
        c_array_ptr(buf),
        1024U
    )
    
    # we don't do anything with this yet,
    # but in time we will
    err = _get_errno(c_ref(err))

    return c_array_ptr(buf)

    # str() method
    # takes in a ptr to i8
    # returns a dynamically created string object

    # set the string object size with the return value
    # maybe we can get wide and then convert it to UTF-8?
    # save us a step? would that give us the length automatically?
    # https://msdn.microsoft.com/en-us/library/windows/desktop/dd319072(v=vs.85).aspx
    # return the string object
}
